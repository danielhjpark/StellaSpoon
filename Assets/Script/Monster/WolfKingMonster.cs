using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class WolfKingMonster : MonsterBase
{
    private Coroutine currentPatternCoroutine;

    private int nextPattern = 0;

    private static readonly int THROW = 0; //던지기
    private static readonly int PILLAR = 1; //기둥세우기
    private static readonly int SPAWN = 2; //스폰

    public static bool isThrowWarning = false; //던지기 경고 여부

    [SerializeField]
    private float PatternRange = 15.0f;

    [Header("Throw")]
    [SerializeField]
    private int waitThrowTime; //던지기 기다리는 시간
    [SerializeField]
    private Transform[] throwPosition; //투척물 위치
    [SerializeField]
    private GameObject throwObjectPrefab; //투척물 오브젝트 프리팹
    private int throwcount = 0; //투척물 횟수
    [SerializeField]
    private GameObject warningPrefab; // 빨간 경고 프리팹

    [Header("Pillar")]
    [SerializeField]
    private float pillarRange = 5.0f; //기둥 세우기 범위
    [SerializeField]
    private GameObject pillarPrefab; //기둥 프리팹
    private int pillarCount = 0; //기둥 세우기 횟수
    [SerializeField]
    private float pillarTime = 7.0f; //기둥 나오는 시간

    [Header("Spawn")]
    [SerializeField]
    private GameObject silverSpawnPrefab; //실버울프 스폰 프리팹
    [SerializeField]
    private GameObject novaSpawnPrefab; //오바울프 스폰 프리팹
    [SerializeField]
    private float spawnRange = 5f; //스폰 범위
    private int silverSpawnCount = 2; //실버울프 스폰 횟수
    private int novaSpawnCount = 1; //노바울프 스폰 횟수

    [Header("Health UI")]
    [SerializeField]
    private GameObject bossHealthUI;
    [SerializeField]
    private Slider bossHealthSlider;

    private bool isPlayerInRange = false;

    protected override void Start()
    {
        base.Start();

        if (bossHealthUI != null)
        {
            bossHealthUI.SetActive(false);
        }

        if (bossHealthSlider != null)
        {
            bossHealthSlider.maxValue = maxHealth;
            bossHealthSlider.value = currentHealth;
        }
    }

    private void Update()
    {
        base.Update();

        if (distanceToPlayer <= playerDetectionRange && !isPlayerInRange)
        {
            isPlayerInRange = true;
            if (bossHealthUI != null)
            {
                bossHealthUI.SetActive(true);
            }
        }
        else if (distanceToPlayer > playerDetectionRange && isPlayerInRange)
        {
            isPlayerInRange = false;
            if (bossHealthUI != null)
            {
                bossHealthUI.SetActive(false);
            }
        }
        // 공격 범위 감지
        if (inAttackRange && !isAttack)
        {
            HandleAttack(); // 플레이어가 범위 안으로 다시 들어오면 공격
        }
        else if (!inAttackRange && isAttack)
        {
            // 범위 벗어나면 현재 패턴 중지 및 상태 초기화
            if (currentPatternCoroutine != null)
            {
                StopCoroutine(currentPatternCoroutine);
                currentPatternCoroutine = null;
            }
            isAttack = false;
        }
    }

    protected override void HandleAttack()
    {
        if (isAttack || currentPatternCoroutine != null) return; // 이미 공격 중이면 리턴

        animator.SetBool("Walk", false);

        isAttack = true;
        currentPatternCoroutine = StartCoroutine(Throw());

    }
    private IEnumerator Throw()
    {
        if (isDead) yield break; //죽었으면 코루틴 종료
        animator.SetBool("Walk", false);
        if (!inAttackRange) yield break; //공격 범위 안에 플레이어가 없으면 공격하지 않음

        foreach (Transform pos in throwPosition)
        {
            //경고 효과 표시
            StartCoroutine(ShowThrowGroundEffect(pos));

        }
        throwcount++;
        if (throwcount < 2)
        {
            yield return new WaitForSeconds(6.0f); //3초 대기
            nextPattern = THROW;
            currentPatternCoroutine = null;
            nextPatternPlay();
        }
        else
        {
            throwcount = 0;
            yield return new WaitForSeconds(4.0f); //4초 대기
            nextPattern = PILLAR;
            currentPatternCoroutine = null; // 코루틴 상태 초기화
            nextPatternPlay();
        }
    }

    private IEnumerator ShowThrowGroundEffect(Transform pos)
    {
        if (isDead) yield break; //죽었으면 코루틴 종료
        Vector3 targetPosition = player.transform.position;//준비 시 플레이어의 현재 위치 저장
        Vector3 middlePosition = transform.position + ((targetPosition - pos.position) / 2);//플레이어와 중간지점 계산
        yield return new WaitForSeconds(0.7f);
        isThrowWarning = true;

        GameObject warning = Instantiate(warningPrefab, new Vector3(pos.position.x, transform.position.y + 0.01f, pos.position.z), pos.rotation);//경고 오브젝트 생성
        Vector3 warnRot = warning.transform.rotation.eulerAngles;
        warnRot.x = 90; //X축 회전값을 90도로 조정
        warning.transform.rotation = Quaternion.Euler(warnRot);
        warning.transform.localScale = new Vector3(1.5f, 10, 1);//길이 조정

        yield return new WaitForSeconds(waitThrowTime);

        ThrowObjectSpawn(pos);//투척물 생성
        Destroy(warning);

        StartCoroutine(StartAttack01());
    }

    private IEnumerator StartAttack01()
    {
        if (isDead) yield break; //죽었으면 코루틴 종료
        animator.SetTrigger("Attack1");
        // 애니메이션이 끝날 때까지 대기
        while (animator.GetCurrentAnimatorStateInfo(0).IsName("Attack1"))
            yield return null;
    }

    private void ThrowObjectSpawn(Transform pos)
    {
        if (isDead) return; //죽었으면 코루틴 종료
        // 기존 투척물 생성
        GameObject throwObject = Instantiate(throwObjectPrefab, pos.position, pos.rotation);
        throwObject.GetComponent<LunaWolfKingBullet>().thirdPersonController = thirdPersonController;
        throwObject.GetComponent<LunaWolfKingBullet>().damage = damage;

        StartCoroutine(WaitThrowDelay(1f));
    }

    private IEnumerator WaitThrowDelay(float delayTime)
    {
        if (isDead) yield break; //죽었으면 코루틴 종료
        yield return new WaitForSeconds(delayTime);
        isThrowWarning = false;
    }

    private IEnumerator Pillar()
    {
        if (isDead) yield break; //죽었으면 코루틴 종료
        animator.SetBool("Walk", false);
        if (!inAttackRange) yield break; //공격 범위 안에 플레이어가 없으면 공격하지 않음
        pillarCount = Random.Range(4, 6); //기둥 세우기 횟수

        yield return new WaitForSeconds(2.0f); //2초 대기
        animator.SetTrigger("Attack4");//애니메이션 재생

        for (int i = 0; i < pillarCount; i++)
        {
            Debug.Log(pillarCount);
            Vector3 randomPos = new Vector3(Random.Range(-pillarRange, pillarRange), 0, Random.Range(-pillarRange, pillarRange));
            GameObject pillar = Instantiate(pillarPrefab, transform.position + randomPos, Quaternion.identity);
            Destroy(pillar, pillarTime); //5초 후 기둥 삭제
        }
        yield return new WaitForSeconds(5.0f); //5초 대기
        nextPattern = SPAWN;
        currentPatternCoroutine = null; // 코루틴 상태 초기화
        nextPatternPlay();
    }

    private IEnumerator Spawn()
    {
        if (isDead) yield break; //죽었으면 코루틴 종료
        animator.SetBool("Walk", false);
        if (!inAttackRange) yield break; //공격 범위 안에 플레이어가 없으면 공격하지 않음
        yield return new WaitForSeconds(2.0f); //2초 대기
        animator.SetTrigger("Buff");//애니메이션 재생
        yield return new WaitForSeconds(1.0f); //1초 대기
        for (int i = 0; i < silverSpawnCount; i++)
        {
            Vector3 randomPos = new Vector3(Random.Range(-spawnRange, spawnRange), 0, Random.Range(-spawnRange, spawnRange));
            GameObject silverWolf = Instantiate(silverSpawnPrefab, transform.position + randomPos, Quaternion.identity);
        }
        for (int i = 0; i < novaSpawnCount; i++)
        {
            Vector3 randomPos = new Vector3(Random.Range(-spawnRange, spawnRange), 0, Random.Range(-spawnRange, spawnRange));
            GameObject novaWolf = Instantiate(novaSpawnPrefab, transform.position + randomPos, Quaternion.identity);
        }
        yield return new WaitForSeconds(3.0f); //3초 대기
        nextPattern = THROW;
        currentPatternCoroutine = null; // 코루틴 상태 초기화
        nextPatternPlay();
    }
    protected void nextPatternPlay()
    {
        if (isDead) return;

        if (currentPatternCoroutine != null)
        {
            StopCoroutine(currentPatternCoroutine);
            currentPatternCoroutine = null;
        }

        switch (nextPattern)
        {
            case 0:
                currentPatternCoroutine = StartCoroutine(Throw());
                Debug.Log("던지기 패턴 실행");
                break;
            case 1:
                currentPatternCoroutine = StartCoroutine(Pillar());
                Debug.Log("기둥 세우기 패턴 실행");
                break;
            case 2:
                currentPatternCoroutine = StartCoroutine(Spawn());
                Debug.Log("스폰 패턴 실행");
                break;
        }
    }

    protected override void OnDrawGizmosSelected()//선택시 보이게 //항상 보이게 OnDrawGizmos
    {
        base.OnDrawGizmosSelected();

        Gizmos.color = Color.white; //기둥 범위
        Gizmos.DrawWireSphere(transform.position, pillarRange);
    }
}
